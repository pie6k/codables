import { Callout } from 'nextra/components';

# Performance

Codables delivers superior performance compared to alternatives while providing a more developer-friendly API.

## Benchmark Results

Based on comprehensive testing with complex data structures:

### Standard JSON with Complex Types
- **Encode**: Codables ~9ms vs SuperJSON ~38ms (**4.2x faster**)
- **Decode**: Codables ~7ms vs SuperJSON ~10ms (**1.4x faster**)

### Complex Data with References
- **Encode**: Codables ~8ms vs SuperJSON ~35ms (**4.4x faster**)
- **Decode**: Codables ~14ms vs SuperJSON ~14ms (**equivalent**)

### Complex Data without References
- **Encode**: Codables ~9ms vs SuperJSON ~37ms (**4.1x faster**)
- **Decode**: Codables ~11ms vs SuperJSON ~16ms (**1.5x faster**)

## Performance Characteristics

### Encoding Performance
- **Optimized algorithms**: Efficient traversal and serialization
- **Minimal allocations**: Reduced memory pressure
- **Fast type detection**: Quick matching of built-in types
- **Reference tracking**: Efficient circular reference detection

### Decoding Performance  
- **Streaming deserialization**: Process data as it's decoded
- **Type reconstruction**: Fast instantiation of complex types
- **Reference resolution**: Efficient circular reference restoration
- **Memory efficient**: Minimal temporary object creation

## Memory Usage

Codables is designed for memory efficiency:

- **Lazy evaluation**: Only process data when needed
- **Efficient references**: Minimal overhead for reference tracking
- **Garbage collection friendly**: Avoids creating unnecessary temporary objects
- **Streaming support**: Can handle large datasets without loading everything into memory

## Optimization Strategies

### For High-Performance Applications

1. **Use custom coders**: Create specialized coders for your specific types
2. **Batch operations**: Process multiple objects together when possible
3. **Lazy loading**: Decode only what you need, when you need it
4. **Reference optimization**: Use `preserveReferences: false` when you don't need object identity

```typescript
// High-performance custom coder
const optimizedCoder = new Coder([YourType1, YourType2]);

// Batch processing
const batch = [obj1, obj2, obj3];
const encoded = optimizedCoder.encode(batch);
const decoded = optimizedCoder.decode(encoded);
```

### Memory-Conscious Usage

```typescript
// For large datasets, consider streaming
function* processLargeDataset(data: any[]) {
  for (const item of data) {
    const encoded = encode(item);
    // Process encoded item
    yield encoded;
  }
}

// Or use copy for memory-efficient cloning
const snapshot = copy(largeObject);
```

## Real-World Performance

In production applications, Codables typically shows:

- **3-4x faster encoding** than SuperJSON
- **1.5-2x faster decoding** than SuperJSON
- **Lower memory usage** due to efficient algorithms
- **Better scalability** with large datasets

## Performance Monitoring

Monitor performance in your application:

```typescript
// Simple performance measurement
function measurePerformance<T>(fn: () => T, label: string): T {
  const start = performance.now();
  const result = fn();
  const end = performance.now();
  console.info(`${label}: ${end - start}ms`);
  return result;
}

// Usage
const encoded = measurePerformance(
  () => coder.encode(largeObject),
  "Encoding"
);

const decoded = measurePerformance(
  () => coder.decode(encoded),
  "Decoding"
);
```

<Callout type="info">
Performance numbers are based on typical workloads. Actual performance may vary depending on data structure complexity, JavaScript engine optimizations, and hardware specifications.
</Callout>

<Callout type="tip">
For maximum performance, profile your specific use cases. Codables provides excellent baseline performance, but custom optimizations can be made for specific patterns.
</Callout>
