import { Callout } from 'nextra/components';

# Integrations

Codables integrates seamlessly with common web development patterns. Here are practical examples for different use cases.

## Local Storage

Create a type-safe wrapper for localStorage that handles complex data types:

```typescript
import { stringify, parse } from "codables";

class LocalStorageValue<T> {
  constructor(private key: string) {}

  get(): T | null {
    const stored = localStorage.getItem(this.key);
    if (!stored) return null;
    
    try {
      return parse(stored);
    } catch {
      return null;
    }
  }

  set(value: T): void {
    localStorage.setItem(this.key, stringify(value));
  }

  remove(): void {
    localStorage.removeItem(this.key);
  }
}

// Usage
const userPrefs = new LocalStorageValue<{
  theme: string;
  lastLogin: Date;
  favorites: Set<string>;
}>("user-preferences");

userPrefs.set({
  theme: "dark",
  lastLogin: new Date(),
  favorites: new Set(["react", "typescript"])
});

const prefs = userPrefs.get();
// prefs.lastLogin instanceof Date === true
// prefs.favorites instanceof Set === true
```

## HTTP APIs

Send complex data structures over HTTP with full type preservation:

```typescript
import { stringify, parse } from "codables";

// API client with Codables integration
class ApiClient {
  async post<T>(url: string, data: T): Promise<T> {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: stringify(data),
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    return parse(await response.json());
  }

  async get<T>(url: string): Promise<T> {
    const response = await fetch(url);
    return parse(await response.json());
  }
}

// Usage
const api = new ApiClient();

const gameState = {
  players: new Set([
    { name: "Alice", score: 100, lastActive: new Date() },
    { name: "Bob", score: 150, lastActive: new Date() }
  ]),
  createdAt: new Date(),
  settings: new Map([["difficulty", "hard"]])
};

// Send complex data
const savedState = await api.post("/api/game-state", gameState);
// All types are preserved on the server and returned
```

## File Persistence

Save rich data formats to disk:

```typescript
import { writeFileSync, readFileSync } from "fs";
import { stringify, parse } from "codables";

class FileStorage<T> {
  constructor(private filePath: string) {}

  save(data: T): void {
    writeFileSync(this.filePath, stringify(data), "utf8");
  }

  load(): T | null {
    try {
      const content = readFileSync(this.filePath, "utf8");
      return parse(content);
    } catch {
      return null;
    }
  }
}

// Usage
const projectStorage = new FileStorage<{
  name: string;
  createdAt: Date;
  files: Map<string, { content: string; modified: Date }>;
}>("./project.json");

const project = {
  name: "My Project",
  createdAt: new Date(),
  files: new Map([
    ["index.ts", { content: "console.info('hello')", modified: new Date() }]
  ])
};

projectStorage.save(project);
const loaded = projectStorage.load();
// All types preserved: Date, Map, etc.
```

## Summary

Everywhere where you work with JSON, you can easily drop in Codables to seamlessly handle complex data types.

<Callout type="info">
These integration patterns work with any JavaScript environment - browser, Node.js, or edge runtimes.
</Callout>
